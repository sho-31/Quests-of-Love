<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kitty Divi's Mood Selection üíñ</title>
<style>
  /* ---------- Original Kitty Divi styles (kept & cleaned) ---------- */
  :root {
    --accent: #ff1493;
    --text: #d63384;
    --card-bg: #ffe6f0;
    --glass: rgba(255,182,193,0.18);
  }

  body {
    margin: 0;
    font-family: 'Comic Sans MS', cursive, sans-serif;
    background: linear-gradient(180deg, #ffe6f0, #ffd1e8, #fff0f5);
    color: var(--text);
    text-align: center;
    min-height: 100vh;
    padding: 20px;
  }
  h1 {
    font-size: 2rem;
    margin-bottom: 20px;
    color: var(--accent);
    text-shadow: 0 0 20px #ff69b4, 0 0 40px var(--accent);
    animation: glow 2s infinite alternate;
    will-change: text-shadow;
  }
  @keyframes glow {
    from { text-shadow: 0 0 20px #ffb6c1, 0 0 40px #ff69b4; }
    to { text-shadow: 0 0 30px #ff69b4, 0 0 60px var(--accent); }
  }

  /* responsive grid */
  #moodGrid {
    display: grid;
    grid-template-columns: repeat(auto-fit,minmax(110px,1fr));
    gap: 15px;
    max-width: 800px;
    margin: 0 auto 30px;
    align-items: start;
  }

  .moodCard {
    background: var(--card-bg);
    border-radius: 20px;
    box-shadow: 0 4px 12px rgba(255, 105, 180, 0.22);
    padding: 15px 10px;
    cursor: pointer;
    user-select: none;
    transition: transform 0.22s ease, box-shadow 0.22s ease, border 0.12s;
    font-size: 1.15rem;
    color: var(--text);
    display: flex;
    flex-direction: column;
    align-items: center;
    border: 2px solid transparent;
  }
  .moodCard:hover, .moodCard:focus {
    transform: translateY(-4px) scale(1.02);
    box-shadow: 0 10px 30px rgba(255, 20, 147, 0.12);
    outline: none;
  }

  .moodEmoji {
    font-size: 2.6rem;
    margin-bottom: 8px;
    line-height: 1;
  }
  .moodLabel {
    font-weight: 700;
    letter-spacing: 0.2px;
  }

  .moodCard.selected {
    transform: scale(1.06);
    box-shadow: 0 10px 36px rgba(255, 20, 147, 0.22);
    border-color: rgba(255,105,180,0.75);
  }

  /* Journal container */
  #journalContainer {
    max-width: 720px;
    margin: 0 auto;
    background: var(--glass);
    padding: 20px 25px;
    border-radius: 22px;
    box-shadow: 0 4px 18px rgba(255, 105, 180, 0.28);
    display: none;
    flex-direction: column;
    align-items: center;
  }
  #journalContainer textarea {
    width: 100%;
    min-height: 120px;
    padding: 12px;
    font-family: 'Comic Sans MS', cursive, sans-serif;
    font-size: 1rem;
    border-radius: 15px;
    border: 1px solid #ff99cc;
    resize: vertical;
    margin-bottom: 12px;
  }

#sendJournalBtn {
  display: inline-block;
  background: linear-gradient(45deg, #ff99cc, #ff66b2);
  border: none;
  padding: 12px 22px;
  border-radius: 28px;
  color: white;
  font-weight: 800;
  font-size: 1rem;
  cursor: pointer;
  box-shadow: 0 6px 18px rgba(255, 105, 180, 0.32);
  transition: transform 180ms ease, box-shadow 180ms ease, opacity 180ms;
  vertical-align: middle;
}

#sendJournalBtn:hover:not(:disabled) {
  transform: translateY(-4px) scale(1.03);
  box-shadow: 0 10px 30px rgba(255, 105, 180, 0.42);
}

#sendJournalBtn:disabled {
  opacity: 0.7;
  cursor: default;
  transform: none !important;
  box-shadow: 0 4px 10px rgba(255, 105, 180, 0.12);
}

/* Back button: softer outline style to contrast the primary pink button */
#backBtn {
  display: inline-block;
  margin-top: 20px;
  background: transparent;
  border: 2px solid rgba(255,105,180,0.18);
  padding: 10px 18px;
  border-radius: 22px;
  color: var(--accent);
  font-weight: 700;
  font-size: 0.98rem;
  cursor: pointer;
  box-shadow: none;
  transition: background 150ms ease, transform 150ms ease, box-shadow 150ms ease;
  vertical-align: middle;
}

#backBtn:hover {
  background: rgba(255,182,193,0.12);
  transform: translateY(-3px);
  box-shadow: 0 6px 18px rgba(255, 105, 180, 0.12);
}


  /* ADDED: intensity slider + attachment area styles */
  .entryControls {
    width: 100%;
    display: flex;
    gap: 12px;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 12px;
    flex-wrap: wrap;
  }
  .intensityWrap {
    display:flex;
    gap:10px;
    align-items:center;
    flex: 1 1 240px;
  }
  .intensityLabel {
    font-weight: 700;
    min-width: 70px;
    text-align:left;
  }
  .intensityVal {
    min-width: 38px;
    font-weight: 800;
    color: var(--accent);
    text-align: right;
  }
  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    border-radius: 999px;
    background: linear-gradient(90deg,#ff99cc,#ff66b2);
    outline: none;
    flex:1;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    border: 3px solid var(--accent);
    cursor: pointer;
  }
  .attachWrap {
    display:flex;
    gap:8px;
    align-items:center;
    justify-content:flex-end;
    flex: 0 0 auto;
  }
  .attachBtn {
    background: linear-gradient(45deg,#ffe6f0,#ffd1e8);
    border: 1px dashed #ff85b2;
    padding: 8px 12px;
    border-radius: 14px;
    color: var(--text);
    font-weight: 700;
    cursor: pointer;
    font-size: 0.95rem;
  }
  .attachmentName {
    font-size: 0.9rem;
    color: #7a7a7a;
    max-width: 160px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  /* small screens tweaks */
  @media (max-width: 420px) {
    #sendJournalBtn, #backBtn {
      padding: 10px 18px;
      font-size: 0.9rem;
    }
    .moodCard {
      font-size: 1rem;
      padding: 12px 8px;
    }
    .moodEmoji {
      font-size: 2.2rem;
    }
  }
</style>
</head>
<body>

<h1>What's the mood today, Divi? üíñ</h1>

<!-- mood grid container ‚Äî will be filled dynamically -->
<div id="moodGrid" role="list" aria-label="Mood options"></div>

<section id="journalContainer" aria-live="polite" aria-label="Mood journal entry">
  <textarea id="journalText" placeholder="Write your feelings here, Divi..."></textarea>

  <!-- ADDED: intensity slider + attachment controls -->
  <div class="entryControls">
    <div class="intensityWrap" aria-hidden="false">
      <div class="intensityLabel">Intensity</div>
      <input id="intensityRange" type="range" min="0" max="10" step="1" value="5" aria-label="Mood intensity slider">
      <div id="intensityValue" class="intensityVal" aria-live="polite">5</div>
    </div>

<div style="display:flex; flex-direction:column; align-items:center; gap:12px;">
  <div class="attachWrap" style="width:100%; display:flex; justify-content:center;">
    <button id="attachBtn" class="attachBtn" type="button">Attach photo / voice</button>
    <div id="attachmentName" class="attachmentName" aria-live="polite"></div>
    <input id="attachmentInput" type="file" accept="image/*,audio/*" style="display:none;" />
  </div>

  <div style="display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap;">
    <button id="sendJournalBtn">Send to Shourya üíå</button>
    <button id="backBtn" style="display:none;">‚Üê Back to moods</button>
  </div>
</div>

  <div id="comfortMessage" role="status" aria-live="polite"></div>
</section>

<script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>
<script>
/* ========== CONFIG ========== */
const EMAILJS_PUBLIC_KEY = 'HY8G_nl5aRSwXkR1y'; // your public key
const EMAILJS_SERVICE_ID = 'service_505fcho';
const EMAILJS_TEMPLATE_ID = 'template_cqov8px'; // change if your template id differs
/* ============================ */

emailjs.init(EMAILJS_PUBLIC_KEY);

/* ---------- Mood data (complete list) ---------- */
const moods = [
  { key: "happy", label: "Happy", emoji: "üòä", message: "Your joy makes the world brighter!", color: "#28C76F" },
  { key: "sad", label: "Sad", emoji: "üò¢", message: "It's okay to feel down; I'm here.", color: "#4A90E2" },
  { key: "angry", label: "Angry", emoji: "üò†", message: "Take a breath ‚Äî you‚Äôre allowed to feel this.", color: "#E94F37" },
  { key: "anxious", label: "Anxious", emoji: "üò∞", message: "One step at a time. Breathe with me.", color: "#FF9F43" },
  { key: "disconnected", label: "Disconnected", emoji: "ü´†", message: "It‚Äôs okay to pull back ‚Äî we‚Äôll reconnect when you‚Äôre ready.", color: "#9E9E9E" },
  { key: "tired", label: "Tired", emoji: "üò¥", message: "Rest is productive too. Be gentle with yourself.", color: "#9B8AE3" },
  { key: "burnt_out", label: "Burnt-out", emoji: "ü•Ä", message: "You‚Äôve done a lot; recharge is essential.", color: "#6B6B6B" },
  { key: "nostalgic", label: "Nostalgic", emoji: "üïäÔ∏è", message: "Sweet memories are treasures.", color: "#CFA0E8" },
  { key: "motivated", label: "Motivated", emoji: "üöÄ", message: "Let‚Äôs make today count!", color: "#FF6B6B" },
  { key: "playful", label: "Playful", emoji: "üò∫", message: "Let‚Äôs laugh and get silly!", color: "#FFD166" },
  { key: "proud", label: "Proud", emoji: "üèÜ", message: "You did that ‚Äî celebrate it!", color: "#00C2A8" },
  { key: "loving", label: "Loving", emoji: "‚ù§Ô∏è", message: "You are my forever.", color: "#FF4D6D" },
  { key: "lonely", label: "Lonely", emoji: "ü•∫", message: "You‚Äôre not alone ‚Äî I‚Äôm listening.", color: "#7A7AFF" },
  { key: "confused", label: "Confused", emoji: "ü§î", message: "It‚Äôs okay to not have all the answers.", color: "#6C757D" },
  { key: "hopeful", label: "Hopeful", emoji: "üå§Ô∏è", message: "Small hope is still hope ‚Äî hold it close.", color: "#8ED081" },
  { key: "jealous", label: "Jealous", emoji: "üíö", message: "Feelings are messy ‚Äî talk it out when ready.", color: "#2E8B57" },
  { key: "pmsing", label: "PMSing", emoji: "üå∏", message: "Tough days are still beautiful. I love you.", color: "#FFB6C1" },
  { key: "periods", label: "Periods", emoji: "ü©∏", message: "Rest my love, I'll text you soon. Don't push yourself for anything, I love you so much my Divanshi, take care of yourself ‚ù§Ô∏è", color: "#FFB86B" },
  { key: "focused", label: "Focused", emoji: "üß†", message: "Flow mode on ‚Äî keep going!", color: "#00A3FF" },
  { key: "distracted", label: "Distracted", emoji: "üåÄ", message: "Tiny reset: 5 min timer, then back.", color: "#B0BEC5" }
];

/* ---------- DOM refs ---------- */
const moodGrid = document.getElementById('moodGrid');
const journalContainer = document.getElementById('journalContainer');
const journalText = document.getElementById('journalText');
const sendBtn = document.getElementById('sendJournalBtn');
const backBtn = document.getElementById('backBtn');
const comfortMessage = document.getElementById('comfortMessage');

// ADDED refs
const intensityRange = document.getElementById('intensityRange'); // ADDED
const intensityValue = document.getElementById('intensityValue'); // ADDED
const attachBtn = document.getElementById('attachBtn'); // ADDED
const attachmentInput = document.getElementById('attachmentInput'); // ADDED
const attachmentName = document.getElementById('attachmentName'); // ADDED

let selectedCardEl = null;
let selectedMoodKey = null;
let attachmentFile = null; // ADDED: stores currently selected file

/* ---------- Render mood cards dynamically ---------- */
function renderMoodGrid() {
  moods.forEach(mood => {
    const card = document.createElement('div');
    card.className = 'moodCard';
    card.tabIndex = 0;
    card.role = 'listitem';
    card.setAttribute('aria-label', `${mood.label} mood`);
    card.dataset.mood = mood.key;
    card.dataset.emoji = mood.emoji;
    card.dataset.color = mood.color;

    // build inner
    card.innerHTML = `
      <div class="moodEmoji" aria-hidden="true">${mood.emoji}</div>
      <div class="moodLabel">${mood.label}</div>
    `;

    // tooltip with short message
    card.title = mood.message;

    // click and keyboard handled with delegation below
    moodGrid.appendChild(card);
  });
}

/* ---------- Selection helpers ---------- */
function setSelectedCard(el) {
  // remove previous
  const prev = moodGrid.querySelector('.moodCard.selected');
  if (prev) {
    prev.classList.remove('selected');
    prev.setAttribute('aria-pressed', 'false');
  }
  if (el) {
    el.classList.add('selected');
    el.setAttribute('aria-pressed', 'true');
    selectedCardEl = el;
    selectedMoodKey = el.dataset.mood;
  } else {
    selectedCardEl = null;
    selectedMoodKey = null;
  }
}

/* ---------- Open / Close journal ---------- */
function openJournalForCard(cardEl) {
  setSelectedCard(cardEl);
  moodGrid.style.display = 'none';
  journalContainer.style.display = 'flex';
  backBtn.style.display = 'inline-block';
  comfortMessage.classList.remove('show');
  comfortMessage.textContent = '';
  journalText.value = '';
  // reset intensity and attachment on open
  if (intensityRange) {
    intensityRange.value = 5;
    intensityValue.textContent = '5';
  }
  attachmentFile = null;
  if (attachmentName) attachmentName.textContent = '';
  journalText.focus();
}

function closeJournal() {
  setSelectedCard(null);
  moodGrid.style.display = 'grid';
  journalContainer.style.display = 'none';
  backBtn.style.display = 'none';
  comfortMessage.classList.remove('show');
  comfortMessage.textContent = '';
  journalText.value = '';
  // reset attachments and intensity
  if (intensityRange) {
    intensityRange.value = 5;
    intensityValue.textContent = '5';
  }
  attachmentFile = null;
  if (attachmentName) attachmentName.textContent = '';
}

/* ---------- Event delegation for grid (click + keyboard) ---------- */
moodGrid.addEventListener('click', (e) => {
  const card = e.target.closest('.moodCard');
  if (!card) return;
  openJournalForCard(card);
});

moodGrid.addEventListener('keydown', (e) => {
  const card = e.target.closest('.moodCard');
  if (!card) return;
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    openJournalForCard(card);
  }
});

/* ---------- Back button ---------- */
backBtn.addEventListener('click', closeJournal);

/* ---------- keyboard shortcut to send: Ctrl/Cmd + Enter ---------- */
journalText.addEventListener('keydown', (e) => {
  const isCmdOrCtrl = e.metaKey || e.ctrlKey;
  if (isCmdOrCtrl && e.key === 'Enter') {
    e.preventDefault();
    sendBtn.click();
  }
});

/* ---------- Intensity UI binding (ADDED) ---------- */
if (intensityRange && intensityValue) {
  intensityRange.addEventListener('input', () => {
    intensityValue.textContent = intensityRange.value;
  });
}

/* ---------- Attachment UI (ADDED) ---------- */
if (attachBtn && attachmentInput && attachmentName) {
  attachBtn.addEventListener('click', () => {
    attachmentInput.click();
  });

  attachmentInput.addEventListener('change', () => {
    const f = attachmentInput.files && attachmentInput.files[0];
    if (!f) {
      attachmentFile = null;
      attachmentName.textContent = '';
      return;
    }
    attachmentFile = f;
    attachmentName.textContent = f.name;
  });
}

/* ---------- helper: read file as DataURL (IMPROVED) ----------
   - If image: resizes & compresses (canvas) to keep payload small.
   - If audio/other: reads but will not include huge data URIs (we only pass filename).
   - If compression can't reduce below threshold, warns the user and returns null.
*/
async function readFileAsDataURL(file) {
  if (!file) return null;

  // limit for embedded DataURL: ~700 KB (approx). EmailJS/templates often choke on huge strings.
  const MAX_EMBED_BYTES = 700 * 1024; // 700 KB

  // helper: read raw dataURL
  function rawReadAsDataURL(f) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(f);
    });
  }

  // If it's an image, try to downscale & compress
  if (file.type && file.type.startsWith('image/')) {
    try {
      const origDataUrl = await rawReadAsDataURL(file);
      // create image
      const img = await new Promise((res, rej) => {
        const i = new Image();
        i.onload = () => res(i);
        i.onerror = rej;
        i.src = origDataUrl;
      });

      // determine target size (keep aspect ratio)
      const MAX_WIDTH = 1024; // px
      const scale = Math.min(1, MAX_WIDTH / Math.max(img.width, img.height));
      const targetW = Math.round(img.width * scale);
      const targetH = Math.round(img.height * scale);

      const canvas = document.createElement('canvas');
      canvas.width = targetW;
      canvas.height = targetH;
      const ctx = canvas.getContext('2d');
      // draw with subtle smoothing
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, 0, 0, targetW, targetH);

      // attempt to compress gradually until under MAX_EMBED_BYTES or quality floor hit
      let quality = 0.85;
      let dataUrl = canvas.toDataURL('image/jpeg', quality);
      // if already small enough, return
      function dataUrlSizeBytes(durl) {
        // remove prefix "data:*/*;base64," then compute length
        const base64 = durl.split(',')[1] || '';
        return Math.ceil((base64.length * 3) / 4);
      }

      let size = dataUrlSizeBytes(dataUrl);
      // reduce quality in steps if needed
      while (size > MAX_EMBED_BYTES && quality > 0.35) {
        quality -= 0.12; // reduce
        dataUrl = canvas.toDataURL('image/jpeg', Math.max(0.35, quality));
        size = dataUrlSizeBytes(dataUrl);
      }

      // if still too large, try smaller dimensions
      if (size > MAX_EMBED_BYTES) {
        // progressively reduce to 640px width
        const SMALL_MAX = 640;
        let scale2 = Math.min(1, SMALL_MAX / Math.max(img.width, img.height));
        const tw = Math.round(img.width * scale2);
        const th = Math.round(img.height * scale2);
        canvas.width = tw;
        canvas.height = th;
        ctx.drawImage(img, 0, 0, tw, th);
        quality = 0.7;
        dataUrl = canvas.toDataURL('image/jpeg', quality);
        size = dataUrlSizeBytes(dataUrl);
        while (size > MAX_EMBED_BYTES && quality > 0.4) {
          quality -= 0.1;
          dataUrl = canvas.toDataURL('image/jpeg', Math.max(0.4, quality));
          size = dataUrlSizeBytes(dataUrl);
        }
      }

      if (size > MAX_EMBED_BYTES) {
        // can't compress enough ‚Äî advise user to pick a smaller photo
        alert("That photo is too large to attach here. Please choose a smaller image (try taking a smaller screenshot or crop it).");
        return null;
      }

      // success
      return dataUrl;
    } catch (err) {
      console.warn('Image processing failed, falling back to raw read', err);
      // fallback: raw data URL but check size
      try {
        const d = await rawReadAsDataURL(file);
        const sizeBytes = Math.ceil(((d.split(',')[1] || '').length * 3) / 4);
        if (sizeBytes > MAX_EMBED_BYTES) {
          alert("That photo is too large to attach here. Please choose a smaller image.");
          return null;
        }
        return d;
      } catch (e) {
        console.error('Fallback read failed', e);
        return null;
      }
    }
  }

  // For audio/other types: read but warn if too large ‚Äî we prefer sending filename only
  if (file.size && file.size > MAX_EMBED_BYTES) {
    // too large to embed safely
    // don't attempt to embed audio ‚Äî return null and we'll only send filename
    alert("That file is large and cannot be embedded. The message will be sent without the actual file; only the filename will be included. (You can send large files via chat or cloud link.)");
    return null;
  }

  // final fallback: small non-image file
  try {
    const smallData = await rawReadAsDataURL(file);
    return smallData;
  } catch (err) {
    console.warn('rawReadAsDataURL failed', err);
    return null;
  }
}

/* ---------- Send flow (FIXED: include many placeholder names so template gets the mood) ---------- */
sendBtn.addEventListener('click', async () => {
  const text = journalText.value.trim();

  if (!selectedMoodKey) {
    alert("Please pick a mood first, Divi üíñ");
    return;
  }
  if (!text) {
    alert("Please write something before sending, Divi üíñ");
    journalText.focus();
    return;
  }
  if (!navigator.onLine) {
    alert("You're offline ‚Äî connect to the internet and try again.");
    return;
  }

  // find mood object
  const mood = moods.find(m => m.key === selectedMoodKey) || {};

  // read attachment if present (IMPROVED)
  let attachmentDataUrl = '';
  let attachmentFilename = '';
  if (attachmentFile) {
    try {
      // attempt to produce a (possibly compressed) data URL for images
      const processed = await readFileAsDataURL(attachmentFile);
      if (processed) {
        attachmentDataUrl = processed;
        attachmentFilename = attachmentFile.name || '';
      } else {
        // processed is null ‚Äî don't send raw data; only send filename
        attachmentDataUrl = '';
        attachmentFilename = attachmentFile.name || '';
      }
    } catch (err) {
      console.warn('Attachment processing failed', err);
      attachmentDataUrl = '';
      attachmentFilename = attachmentFile.name || '';
    }
  }

  // ---- include multiple commonly-used placeholder names so the template always receives the value ----
  const label = (mood.label || selectedMoodKey || '').toString();
  const intensity = (intensityRange && intensityRange.value) ? intensityRange.value.toString() : '5'; // include intensity
  const templateParams = {
    // common names (so any template using any of these will receive the value)
    mood: label,
    mood_tag: label,
    mood_label: label,
    mood_name: label,
    mood_key: mood.key || selectedMoodKey,

    // emoji + color + message + timestamp
    mood_emoji: mood.emoji || '',
    mood_color: mood.color || '#ff99cc',
    mood_message: text,
    timestamp: new Date().toLocaleString(),

    // intensity + attachment fields
    mood_intensity: intensity,
    mood_intensity_label: `${intensity}/10`,
    mood_attachment_name: attachmentFilename,
    mood_attachment_data: attachmentDataUrl // may be '' if not available or too large
  };
  // small debug (console only)
  console.log('Sending templateParams:', templateParams);

  sendBtn.disabled = true;
  sendBtn.textContent = "Sending...";

  try {
    await emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID, templateParams);

    // show comfort message (use the mapped short affirmation if available)
    const shortAffirm = mood.message || "Thank you for sharing, love üíñ";
    comfortMessage.textContent = shortAffirm;
    comfortMessage.classList.add('show');

    // clear text input and attachment
    journalText.value = '';
    attachmentFile = null;
    if (attachmentName) attachmentName.textContent = '';
    // optionally keep journal open so Divi sees feedback; you can auto-close if you want:
    // setTimeout(closeJournal, 1400);
  } catch (err) {
    console.error('EmailJS send failed', err);
    alert("Oops ‚Äî something went wrong while sending. Try again.");
  } finally {
    sendBtn.disabled = false;
    sendBtn.textContent = "Send to Shourya üíå";
  }
});

/* ---------- Initialize ---------- */
renderMoodGrid();

/* Accessibility improvement: allow arrow navigation among mood cards */
(function enableArrowNav() {
  const cardsSelector = '.moodCard';
  document.addEventListener('keydown', (e) => {
    const active = document.activeElement;
    if (!active || !active.matches(cardsSelector)) return;
    if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
      e.preventDefault();
      let next = active.nextElementSibling;
      if (!next) {
        // wrap to first
        next = active.parentElement.querySelector(cardsSelector);
      }
      next.focus();
    } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
      e.preventDefault();
      let prev = active.previousElementSibling;
      if (!prev) {
        // wrap to last
        const list = active.parentElement.querySelectorAll(cardsSelector);
        prev = list[list.length - 1];
      }
      prev.focus();
    }
  });
})();
</script>
</body>
</html>
