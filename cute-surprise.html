
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cute Surprise for Kitty Divi ðŸ’–</title>
<style>
  body {
    font-family: 'Comic Sans MS', cursive, sans-serif;
    background: linear-gradient(180deg, #ffe6f0, #ffd1e8);
    text-align: center;
    color: #d63384;
    overflow-x: hidden;
    margin: 0;
    padding: 0;
  }

  h1 {
    font-size: 3rem;
    margin-top: 40px;
    color: #ff1493;
    text-shadow: 0 0 20px #ff69b4, 0 0 40px #ff1493;
    animation: glow 2s infinite alternate;
  }

  p {
    font-size: 1.2rem;
    max-width: 700px;
    margin: 20px auto;
    line-height: 1.8;
    padding: 0 15px;
  }

  @keyframes glow {
    from { text-shadow: 0 0 20px #ff69b4, 0 0 40px #ff1493; }
    to { text-shadow: 0 0 40px #ff69b4, 0 0 60px #ff1493; }
  }

  .kitty-btn {
    background: linear-gradient(45deg, #ff69b4, #ff1493);
    border: none;
    padding: 15px 40px;
    font-size: 1.2rem;
    color: white;
    border-radius: 30px;
    cursor: pointer;
    box-shadow: 0 5px 15px rgba(255, 20, 147, 0.4);
    transition: all 0.3s ease;
  }
  .kitty-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 8px 25px rgba(255, 20, 147, 0.6);
  }

  /* floating sparkles (non-interactive so they don't block taps) */
  .floating {
    position: fixed;
    animation: floatUp 6s linear infinite;
    bottom: -100px;
    z-index: 10;
    pointer-events: none; /* important â€” don't capture taps */
  }

  @keyframes floatUp {
    0% { transform: translateY(0) scale(0.8); opacity: 1; }
    100% { transform: translateY(-110vh) scale(1.2); opacity: 0; }
  }

  /* Love Button */
  .love-btn {
    display:block;
    margin: 20px auto;
    background-color: #ff4d94;
    color: white;
    border: none;
    padding: 10px 20px;
    font-size: 1.1em;
    border-radius: 25px;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(255,0,102,0.3);
    transition: transform 0.2s ease;
  }
  .love-btn:hover {
    transform: scale(1.05);
  }

  /* Love Message Box */
  #loveMessageBox {
    display:none;
    margin-top: 15px;
    padding: 15px;
    background-color: #ffe6f0;
    border-radius: 15px;
    font-size: 1.1em;
    color: #b30059;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    opacity: 0;
    transform: translateY(8px);
    transition: opacity 350ms ease, transform 350ms ease;
    position: relative; /* keep in document flow below buttons */
    overflow: visible;
    max-width: 700px;
    margin-left: auto;
    margin-right: auto;
    z-index: 1000; /* ensure it's above floating elements */
    line-height: 1.6;
    text-align: left;
    white-space: pre-wrap; /* preserve newlines */
  }

  /* small floating hearts inside box (non-interactive) */
  .heart {
    position: absolute;
    font-size: 18px;
    animation: heartFloat 2s ease-out forwards;
    opacity: 0.95;
    pointer-events: none; /* don't block touches */
  }
  @keyframes heartFloat {
    0% { transform: translateY(0) scale(1); opacity: 1; }
    100% { transform: translateY(-60px) scale(1.4); opacity: 0; }
  }

  /* make the content look a bit nicer on small screens */
  @media (max-width: 420px) {
    h1 { font-size: 2rem; }
    p { font-size: 1rem; padding: 0 12px; }
    #loveMessageBox { font-size: 1rem; padding: 14px; }
  }
</style>
</head>
<body>

  <h1>ðŸ’– I Love You so much my Kitty Divi ðŸ’–</h1>
  <p>
    My lovely Angel, you make my eyes shine, your one glance a bliss so divine.
    The warmth of yours is my safe ad happy place, I just want you to know that 
    till eternity ends and beyond, you will always be my a craving of my gaze.
    With you every day feels as if filled with magic and every breath worth to live.
    You are a gentle warm dream that I never want to wake from.

    Thank you so much my Divanshi, for being who you are.
    And I am so so so proud of you for everything you are my love.
    Ummmmmmmmmaaaaaaaaahhhhhhhhhh on forehead ðŸ’•
  </p>

  <button class="kitty-btn" onclick="startSparkleMode()">âœ¨ Kitty Sparkle Mode</button>

  <!-- New Love Button -->
  <button class="love-btn" id="loveBtn">ðŸ’– Want to know how much Shourya loves you? ðŸ’–</button>
  <div id="loveMessageBox" aria-live="polite"></div>

<script src="https://js.puter.com/v2/"></script>
<script>
/*
  Updated love-button handler:
  - Strong prompt that forces second-person (addressing 'you')
  - Robust extraction of the AI text from different response shapes
  - Replaces escaped \n with real newlines
  - Ensures box becomes visible and scrolls into view
*/

  // keep the "magic level" increasing each click
  let loveLevel = 1;

  function createFloatingItem(symbol) {
    const el = document.createElement('div');
    el.classList.add('floating');
    el.textContent = symbol;
    el.style.fontSize = '2rem';
    el.style.left = Math.random() * 100 + 'vw';
    el.style.animationDuration = (4 + Math.random() * 3) + 's';
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 7000);
  }

  function startSparkleMode() {
    const symbols = ['ðŸ’–', 'ðŸŽˆ'];
    const interval = setInterval(() => {
      const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
      createFloatingItem(randomSymbol);
    }, 300);
    setTimeout(() => clearInterval(interval), 8000);
  }

  // hearts floating inside the message box
  function createHeart(container) {
    const heart = document.createElement("div");
    heart.classList.add("heart");
    heart.textContent = "ðŸ’–";
    const leftPct = 8 + Math.random() * 77;
    heart.style.left = leftPct + "%";
    heart.style.bottom = "8px";
    container.appendChild(heart);
    setTimeout(() => heart.remove(), 2200);
  }

  // try many shapes and pick the most plausible human text
  function extractTextFromResponse(resp) {
    if (!resp) return "";
    // if it's already a string, return cleaned string
    if (typeof resp === "string") {
      return resp;
    }

    // Common shapes:
    //  - resp.message.content (string)
    //  - resp.message.content[0].text
    //  - resp.choices[0].message.content
    //  - resp.output[0].content[0].text
    //  - resp.text or resp.content
    try {
      if (resp.message && (resp.message.content || resp.message.text)) {
        // message.content might be string or array; handle both
        const mc = resp.message.content;
        if (typeof mc === "string") return mc;
        if (Array.isArray(mc) && mc.length) {
          // try to find a string inside
          for (const item of mc) {
            if (typeof item === "string") return item;
            if (item && typeof item === "object") {
              // sometimes {type: "output_text", text: "..." }
              if (item.text) return item.text;
              if (item.content) {
                if (typeof item.content === "string") return item.content;
                if (Array.isArray(item.content)) {
                  for (const c of item.content) if (typeof c === "string") return c;
                }
              }
            }
          }
        }
      }

      if (resp.choices && Array.isArray(resp.choices) && resp.choices.length) {
        const c = resp.choices[0];
        if (c.message && (c.message.content || c.message.text)) {
          return c.message.content || c.message.text;
        }
        if (typeof c.text === "string") return c.text;
      }

      if (resp.output && Array.isArray(resp.output) && resp.output.length) {
        const out = resp.output[0];
        if (out.content && Array.isArray(out.content) && out.content.length) {
          // find first string inside
          for (const ct of out.content) {
            if (typeof ct === "string") return ct;
            if (ct && ct.text) return ct.text;
            if (ct && ct.content && typeof ct.content === "string") return ct.content;
          }
        }
      }

      // fallback: look for keys 'text' or 'content' in root
      if (resp.text && typeof resp.text === "string") return resp.text;
      if (resp.content && typeof resp.content === "string") return resp.content;

      // final fallback: find the longest string value inside the object (helps avoid metadata)
      let longest = "";
      function walk(o) {
        if (!o) return;
        if (typeof o === "string") {
          if (o.length > longest.length) longest = o;
        } else if (Array.isArray(o)) {
          for (const item of o) walk(item);
        } else if (typeof o === "object") {
          for (const k in o) {
            if (!Object.prototype.hasOwnProperty.call(o, k)) continue;
            walk(o[k]);
          }
        }
      }
      walk(resp);
      return longest;
    } catch (e) {
      console.error("extractTextFromResponse error", e);
      return "";
    }
  }

  // clean escape sequences like \n -> actual newline, and trim
  function cleanText(s) {
    if (!s) return "";
    // Convert escaped newlines to real newlines
    s = s.replace(/\\n/g, "\n");
    // Remove excessive quotes around the whole string
    s = s.replace(/^\s*"(.*)"\s*$/s, "$1");
    return s.trim();
  }

  document.getElementById("loveBtn").addEventListener("click", async () => {
    const btn = document.getElementById("loveBtn");
    const box = document.getElementById("loveMessageBox");

    btn.disabled = true;
    box.style.display = "block";
    box.style.opacity = "0";
    box.style.transform = "translateY(8px)";
    box.textContent = "âœ¨ Thinking about your magical bond with Divanshi... âœ¨";

    for (let i = 0; i < 5; i++) {
      setTimeout(() => createHeart(box), i * 160);
    }

    setTimeout(() => {
      try { box.scrollIntoView({ behavior: "smooth", block: "center" }); } catch(e){}
    }, 120);

    // Prompt: force second-person, avoid "I" statements, human tone
    const prompt = `
Compose a romantic, poetic love note **from Shourya to Divanshi** that speaks directly *to Divanshi* using **second-person** perspective. 
Use "you" and address how Shourya sees, admires, and cherishes her. 
**Do not** write primarily in the first person (avoid starting sentences with "I"). 
Use warm metaphors and gentle imagery (stars, light, gardens, breeze) and short sweet lines.
End with one unique, tender closing line. Keep the tone affectionate, simple, and clearly written in plain English (no JSON, no metadata).
Love Level: ${loveLevel}.
`.trim();

    try {
      // call puter.ai.chat if available
      let raw = null;
      if (window.puter && puter.ai && typeof puter.ai.chat === "function") {
        raw = await puter.ai.chat(prompt, { model: "gpt-4.1-nano" });
      } else {
        // puter unavailable â€” simulate slight delay to keep UX consistent
        await new Promise(r => setTimeout(r, 350));
        throw new Error("Puter not available");
      }

      // extract human text
      let extracted = extractTextFromResponse(raw);
      extracted = cleanText(extracted);

      // if nothing found, fallback friendly message
      if (!extracted) {
        extracted = `Divanshi â€” you glow like a gentle moon, softening every shadow. Know that Shourya admires and cherishes you deeply, and every thought of you feels like home. ðŸ’•`;
      }

      // reveal the message
      setTimeout(() => {
        box.textContent = extracted;
        box.style.opacity = "1";
        box.style.transform = "translateY(0)";
        try { box.scrollIntoView({ behavior: "smooth", block: "center" }); } catch(e){}
      }, 300);

    } catch (err) {
      console.error("Love message error:", err);
      const fallback = `Divanshi â€” you shine with a warmth that turns ordinary moments into gentle wonders. Shourya cherishes you and your every smile. ðŸ’•`;
      setTimeout(() => {
        box.textContent = fallback;
        box.style.opacity = "1";
        box.style.transform = "translateY(0)";
        try { box.scrollIntoView({ behavior: "smooth", block: "center" }); } catch(e){}
      }, 200);
    } finally {
      loveLevel++;
      btn.disabled = false;
    }
  });
</script>

</body>
</html>
